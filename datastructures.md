# 1. 算法复杂度

程序 = 数据结构 + 算法 —— Niklaus Wirth(瑞士，1984年图灵奖获得者)

数据结构是一种存储和组织数据的方式，指在便于访问和修改。

**算法是一组完成特定任务的有穷指令序列**

所有的算法必须满足以下标准：

* 输入：有0个或多个由外部提供的输入量。

* 输出：至少产生一个输出量

* 确定性：每条指令都有明确的语义，无歧义

* 有限性：算法的任何一条指令都能在有限步之内结束

* 有效性：每一条指令都必须足够简单，原则上，只用纸和笔就可以处理这一条指令，仅仅满足条件3中的要求还是不够，指令必须是可行的。

## 1.1 算法的效率

**度量算法的指标**

* 时间复杂度

时间复杂度也成为渐进时间复杂度，T(n) = O(f(n))

随着问题规模 n 的增大，算法执行时间的增长率和f(n)增长率成正比。

**程序运行的总时间主要和两点相关：**

执行每条语句的耗时

每条语句的执行频率

* 空间复杂度

描述某个算法对应的程序想要在计算机上执行，除了需要内存空间来存储程序代码和输入数据之外，<font color='blue'>还行要的额外空间</font>。

**插入排序**

INSERTION-SORT，数组A[1..n]，包含长度为 n 的要排序的序列该算法在数组 A 中重排这些数，任何时候，最多只有其中常数个数，存储在数组外面，排序后，得到数组 A 中是已拍好序的。

![](./Assets/img/datastructures/insertionsort.png)

第一行：虽然我们是从 2 执行的，但是在第 n + 1 条时，虽然不进入循环，但是也已经比对过了。所以是 n 次执行。

算法的最好情况就是，每次都不满足 5 行的执行条件，所以 6、7行不执行，5、8执行 n - 1 次。因此我们可以得到在<font color='blue'>最好情况下的复杂度：给出的数组已经是排好序的。</font>

$$
\begin{equation} 
\begin{aligned} 
  T(n) &= c_1n + c_2(n - 1) + c_4(n - 1) + c_5(n-1) + c_8(n-1)\\
       &= (c_1 + c_2 + c_4 + c_5 + c_8)n - (c_2 + c_4 + c_5 + c_8) \nonumber
\end{aligned}
\end{equation}
$$

<font color='red'>我们可以把运行时间表示为: $an + b$ </font>

<font color = 'red'> 其中 a 和 b 依赖于代价 $c_i$ ，因此运行时间是 n 的线性函数。</font>

$$
T(n) = O(n)
$$

然而大部分情况下都是不好的，<font color='blue'>最坏的情况下：</font>

如果输入数组是从大到小的排序，则会导致最坏情况。我们必须将每个元素 A[j] 与整个拍好序的子数组 A[1...j-1]中每个元素进行比较。所以 j = 2时，比较 2 次，j = 3 时， 比较3 次 ... j = n 时，比较 n 次。




